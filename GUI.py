from tkinter import*
from tkinter import Button
import tkinter as tk
from PIL import Image,ImageTk
import matplotlib.pyplot as plt
from InsertionSort_final import compare_insertion
from MergeSort_final import compare_mergee
from HeapSort_final import compare_heap
from QuickSort_final import compare_quick
from CountingSort_final import compare_counting
from RadixSort_final import compare_radix
from BubbleSort_final import compare_bubble
from SelectionSort_final import compare_selection
from InsertionSort_final import plot_insertion_steps_notation
from MergeSort_final import plot_merge_steps_notation
from HeapSort_final import plot_heap_steps_notation
from CountingSort_final import plot_counting_steps_notation
from RadixSort_final import plot_radix_steps_notation
from QuickSort_final import plot_quick_steps_notation
from BubbleSort_final import plot_bubble_steps_notation
from SelectionSort_final import plot_selection_steps_notation
from SelectionSort_final import plot_selection_steps
from MergeSort_final import plot_merge_steps
from HeapSort_final import plot_heap_steps
from CountingSort_final import plot_counting_steps
from RadixSort_final import plot_radix_steps
from QuickSort_final import plot_quick_steps
from BubbleSort_final import plot_bubble_steps
from SelectionSort_final import plot_selection_steps
from InsertionSort_final import plot_insertion_steps

from tkinter import messagebox
root= Tk() 
root.title('My Algorithms App')
root.iconbitmap('algorithms ico.ico')
root.geometry("1200x900")
root.configure(background='black')
def popup(window1):
    messagebox.showinfo("window1","please wait some time loadingg..")
def open_insertion():
    root.withdraw()
    new_insertion=Toplevel()
    new_insertion.title('Insertion Sort')
    new_insertion.geometry("1200x800")
    new_insertion.configure(background='#BC8F8F')
    new_insertion.iconbitmap('algorithms ico.ico')
    ins_label1 =Label(new_insertion,text="Welcome to Insertion Sort page!!" , bg='#BC8F8F' , font=('Arial Black', 20), fg='white',padx=10,pady=10)
    ins_label1.pack()
    ins_label2 =Label(new_insertion,text="Brief on Insertion Sort" , fg='black', bg='#BC8F8F',font=('Arial Black', 20),padx=10,pady=10)
    ins_label2.pack()
    ins_label3=Label (new_insertion, text=" Definition : It is a simple sorting algorithm that is like sort playing cards in your hands.", bg='#BC8F8F',font=('Arial Black', 16),padx=10,pady=10)
    ins_label4=Label (new_insertion ,text="The array is split into a sorted and an unsorted part until putting the card in the correct position", bg='#BC8F8F',font=('Arial Black', 16),padx=10,pady=10)
    ins_label3.pack()
    ins_label4.pack()
    ins_label5=Label(new_insertion, text=" Time Complexity: O(n^2)" , bg='#BC8F8F',font=('Arial Black', 16),padx=10,pady=10 )
    ins_label5.pack()
    img1_ins=ImageTk.PhotoImage(Image.open("insertion_img.jpg"))
    panel=Label(new_insertion,image=img1_ins)
    panel.photo=img1_ins
    panel.pack()
    btn_insertion=Button(new_insertion,text="Insertion Steps",command=lambda: [popup(new_insertion),plot_insertion_steps()], fg='white', bg='black' , font=('Times', 20))
    btn_insertion.pack(padx=10,pady=10)
    btn_insertion=Button(new_insertion,text="Insertion Steps vs notation ",command=lambda: [popup(new_insertion),plot_insertion_steps_notation()], fg='white', bg='black' , font=('Times', 20))
    btn_insertion.pack(padx=10,pady=10)
    btn_insertion=Button(new_insertion,text="Back",command=lambda:[back(new_insertion)], fg='white', bg='black' , font=('Times', 20))
    btn_insertion.pack(padx=10,pady=10)
    
   
def open_merge():
    root.withdraw()
    new_merge=Toplevel()
    new_merge.title('Merge Sort')
    new_merge.geometry("1200x800")
    new_merge.configure(background='#BC8F8F')
    new_merge.iconbitmap('algorithms ico.ico')
    m_label1 =Label(new_merge,text="Welcome to Merge Sort page!!" , font=('Arial Black', 20),  bg='#BC8F8F',padx='100',pady='10',fg='white')
    m_label1.pack()
    m_label2 =Label(new_merge,text="Merge Sort brief " , font=('Arial Black', 20) ,  bg='#BC8F8F' ,fg='black',padx='100',pady='10')
    m_label2.pack()
    m_label3=Label (new_merge , text=" Definition : It is a Divide and Conquer algorithm. It divides the input array into two halves.", bg='#BC8F8F',font=('Arial Black', 16),padx='100',pady='10' )
    m_label4=Label (new_merge ,text="And then it calls itself for the two halves, and then merges the two sorted halves.",font=('Arial Black', 16), bg='#BC8F8F',padx='100',pady='10')
    m_label3.pack()
    m_label4.pack()
    m_label5=Label(new_merge, text=" Time Complexity: O(n*log(n))" , bg='#BC8F8F', font=('Arial Black', 16),padx='100',pady='10' )
    m_label5.pack()
    img_merge=ImageTk.PhotoImage(Image.open("merge_img.jpg"))
    panel=Label(new_merge,image=img_merge)
    panel.photo=img_merge
    panel.pack()
    btn_merge =Button(new_merge ,text="Merge Sort steps ",command=plot_merge_steps, fg='white', bg='black', padx='100',pady='10' , font=('Times', 20))
    btn_merge.pack(padx=10,pady=10)
    btn_merge =Button(new_merge ,text="Merge Sort steps vs notation ",command=plot_merge_steps_notation, fg='white', bg='black', padx='100',pady='10' , font=('Times', 20))
    btn_merge.pack(padx=10,pady=10)
    btn_merge =Button(new_merge ,text="Back",command=lambda:[back(new_merge)], fg='white', bg='black', padx='100',pady='10' , font=('Times', 20))
    btn_merge.pack(padx=10,pady=10)
def open_heap():
    root.withdraw()
    new_heap=Toplevel()
    new_heap.title('Heap Sort')
    new_heap.geometry("1200x800")
    new_heap.configure(background='#BC8F8F')
    new_heap.iconbitmap('algorithms ico.ico')
    h_label1 =Label(new_heap,text="Welcome to Heap Sort page" , font=('Arial Black', 20), bg='#BC8F8F',padx='100',pady='10', fg='white')
    h_label1.pack()
    h_label2 =Label(new_heap,text="Heap Sort brief " , font=('Arial Black', 20) , bg='#BC8F8F', fg='black',padx='100',pady='10')
    h_label2.pack()
    h_label3=Label (new_heap , text=" Definition : It is a comparison-based sorting technique based on Binary Heap.", bg='#BC8F8F' ,font=('Arial Black', 16),padx='100',pady='10' )
    h_label3.pack()
    h_label4=Label (new_heap ,text="We first find the minimum element and place the minimum element at the beginning if we will use min Heap.", bg='#BC8F8F',font=('Arial Black', 15),padx='100',pady='10')
    h_label4.pack()
    h_label5=Label(new_heap ,text=" and then We start repeating the same process for the remaining elements. ",font=('Arial Black', 16), bg='#BC8F8F',padx='100',pady='10')
    h_label5.pack()
    h_label6=Label(new_heap, text=" Time Complexity: O(n*log(n))" , bg='#BC8F8F',font=('Arial Black', 16),padx='100',pady='10' )
    h_label6.pack()
    img_heap=ImageTk.PhotoImage(Image.open("heap_img.jpeg"))
    panel_heap=Label(new_heap,image=img_heap)
    panel_heap.photo=img_heap
    panel_heap.pack()
    btn_heap= Button (new_heap, text="Heap Sort steps",command=plot_heap_steps, fg='white', bg='black', padx='100',pady='10' , font=('Times', 20))
    btn_heap.pack(padx=10,pady=10)
    btn_heap= Button (new_heap, text="Heap Sort steps vs notation",command=plot_heap_steps_notation, fg='white', bg='black', padx='100',pady='10' , font=('Times', 20))
    btn_heap.pack(padx=10,pady=10)
    btn_heap= Button (new_heap,text="Back",command=lambda:[back(new_heap)], fg='white', bg='black', padx='100',pady='10' , font=('Times', 20))
    btn_heap.pack(padx=10,pady=10)
    
def open_quick():
    root.withdraw()
    new_quick=Toplevel()
    new_quick.title('Quick Sort')
    new_quick.geometry("1200x800")
    new_quick.configure(background='#BC8F8F')
    new_quick.iconbitmap('algorithms ico.ico')
    h_label1 =Label(new_quick,text="Welcome to Quick Sort page!!" , font=('Arial Black', 20), bg='#BC8F8F',padx='100',pady='10',fg='white')
    h_label1.pack()
    h_label2 =Label(new_quick,text="Quick Sort brief " , font=('Arial Black', 20) , bg='#BC8F8F', fg='black',padx='100',pady='10')
    h_label2.pack()
    h_label3=Label (new_quick , text=" Definition: It is a Divide and Conquer algorithm. It picks an element as pivot and partition the given array around the picked pivot.", bg='#BC8F8F' ,font=('Arial Black', 16),padx='100',pady='10' )
    h_label3.pack()
    h_label4=Label (new_quick ,text=" Then, We put the elements around the pivot correctly to make left of pivot less than it,",bg='#BC8F8F' ,font=('Arial Black', 16),padx='100',pady='10')
    h_label5=Label (new_quick , text=" and right side greater than it, until pivot becomes in correct place ,then we start choosing another pivot.", bg='#BC8F8F',font=('Arial Black', 16),padx='100',pady='10')
    h_label4.pack()
    h_label5.pack()
    h_label6=Label(new_quick , text=" Time Complexity: O(n*log(n))" , bg='#BC8F8F',font=('Arial Black', 16),padx='100',pady='10' )
    h_label6.pack()
    img_quick=ImageTk.PhotoImage(Image.open("quick_img.jpg"))
    panel_quick=Label(new_quick,image=img_quick)
    panel_quick.photo=img_quick
    panel_quick.pack()
    btn_quick= Button (new_quick, text="Quick Sort steps",command=plot_quick_steps, fg='white', bg='black', padx='100',pady='10' , font=('Times', 20))
    btn_quick.pack(padx=10,pady=10)
    btn_quick= Button (new_quick, text="Quick Sort steps vs notation",command=plot_quick_steps_notation, fg='white', bg='black', padx='100',pady='10' , font=('Times', 20))
    btn_quick.pack(padx=10,pady=10)
    btn_quick= Button (new_quick, text="Back",command=lambda:[back(new_quick)], fg='white', bg='black', padx='100',pady='10' , font=('Times', 20))
    btn_quick.pack(padx=10,pady=10)
def open_counting():
    root.withdraw()
    new_counting=Toplevel()
    new_counting.title('Counting Sort')
    new_counting.geometry("1200x800")
    new_counting.configure(background='#BC8F8F')
    new_counting.iconbitmap('algorithms ico.ico')
    h_label1 =Label(new_counting,text="Welcome to Counting Sort page!!" , font=('Arial Black', 20), bg='#BC8F8F',padx='100',pady='10',fg='white')
    h_label1.pack()
    h_label2 =Label(new_counting,text="Counting Sort brief" , font=('Arial Black', 20) , bg='#BC8F8F', fg='black',padx='100',pady='10')
    h_label2.pack()
    h_label3=Label (new_counting , text=" Definition: It is based on keys between a specific range. It works by counting the number of objects having  ", bg='#BC8F8F' ,font=('Arial Black', 16),padx='100',pady='10' )
    h_label3.pack()
    h_label4=Label (new_counting ,text=" distinct key values (kind of hashing).Then doing some arithmetic to calculate the position of each object in the output sequence.",bg='#BC8F8F' ,font=('Arial Black', 16),padx='100',pady='10')
    h_label4.pack()
    h_label5=Label(new_counting, text=" Time Complexity: O(n+k)" , bg='#BC8F8F',font=('Arial Black', 16),padx='100',pady='10' )
    h_label5.pack()
    img_counting=ImageTk.PhotoImage(Image.open("counting sort.jpeg"))
    panel=Label(new_counting,image=img_counting)
    panel.photo=img_counting
    panel.pack()
    btn_counting= Button (new_counting, text="Counting Sort Steps",command=plot_counting_steps, fg='white', bg='black', padx='100',pady='10' , font=('Times', 20))
    btn_counting.pack(padx=10,pady=10)
    btn_counting= Button (new_counting, text="Counting steps vs notation",command=plot_counting_steps_notation, fg='white', bg='black', padx='100',pady='10' , font=('Times', 20))
    btn_counting.pack(padx=10,pady=10)
    btn_counting= Button (new_counting, text="Back",command=lambda:[back(new_counting)], fg='white', bg='black', padx='100',pady='10' , font=('Times', 20))
    btn_counting.pack(padx=10,pady=10)
def open_radix():
    root.withdraw()
    new_radix=Toplevel()
    new_radix.title('Radix Sort')
    new_radix.geometry("1200x800")
    new_radix.configure(background='#BC8F8F')
    new_radix.iconbitmap('algorithms ico.ico')
    h_label1 =Label(new_radix,text="Welcome to Radix Sort page" ,font=('Arial Black', 20), bg='#BC8F8F',padx='100',pady='10',fg='white')
    h_label1.pack()
    h_label2 =Label(new_radix,text="Radix Sort brief " , font=('Arial Black', 20) , bg='#BC8F8F', fg='black',padx='100',pady='10')
    h_label2.pack()
    h_label3=Label (new_radix , text="Definition: It is based on doing digit by digit sort starting from least significant digit to most significant digit.", bg='#BC8F8F' ,font=('Arial Black', 15),padx='100',pady='10' )
    h_label3.pack()
    h_label4=Label (new_radix ,text=" Radix sort uses counting sort as a subroutine to sort.",bg='#BC8F8F' ,font=('Arial Black', 16),padx='100',pady='10')
    h_label4.pack()
    h_label5=Label(new_radix , text=" Time Complexity:O (d* (n+k))" , bg='#BC8F8F',font=('Arial Black', 16),padx='100',pady='10' )
    h_label5.pack()
    img_radix=ImageTk.PhotoImage(Image.open("radix_img.jpeg"))
    panel_radix=Label(new_radix,image=img_radix)
    panel_radix.photo=img_radix
    panel_radix.pack()
    btn_radix= Button (new_radix, text="Radix Sort steps",command= lambda: [popup(new_radix),plot_radix_steps()], fg='white', bg='black', padx='100',pady='10' , font=('Times', 20))
    btn_radix.pack(padx=10,pady=10)
    btn_radix=Button(new_radix,text="Radix Sort vs notation",command=lambda: [popup(new_radix),plot_radix_steps_notation()], fg='white', bg='black' , font=('Times', 20))
    btn_radix.pack(padx=10,pady=10)
    btn_radix= Button (new_radix, text="Back",command=lambda:[back(new_radix)], fg='white', bg='black', padx='100',pady='10' , font=('Times', 20))
    btn_radix.pack(padx=10,pady=10)
def open_bubble():
    root.withdraw()
    new_bubble=Toplevel()
    new_bubble.title('Bubble Sort')
    new_bubble.geometry("1200x800")
    new_bubble.configure(background='#BC8F8F')
    new_bubble.iconbitmap('algorithms ico.ico')
    h_label1 =Label(new_bubble,text="Welcome to Bubble Sort page!!" , font=('Arial Black', 20), bg='#BC8F8F',padx='100',pady='10', fg='white')
    h_label1.pack()
    h_label2 =Label(new_bubble,text="Bubble Sort brief " , font=('Arial Black', 20) , bg='#BC8F8F', fg='black',padx='100',pady='10')
    h_label2.pack()
    h_label3=Label (new_bubble , text=" It is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in wrong order.", bg='#BC8F8F' ,font=('Arial Black', 15),padx='100',pady='10' )
    h_label3.pack()
    h_label4=Label(new_bubble , text=" Time Complexity: O(n^2)" , bg='#BC8F8F',font=('Arial Black', 16),padx='100',pady='10' )
    h_label4.pack()
    img_bubble=ImageTk.PhotoImage(Image.open("bubble_img.gif"))
    panel_bubble=Label(new_bubble,image=img_bubble)
    panel_bubble.photo=img_bubble
    panel_bubble.pack()
    btn_bubble= Button (new_bubble, text="Bubble Sort steps Graph",command=lambda: [popup(new_bubble),plot_bubble_steps()], fg='white', bg='black', padx='100',pady='10' , font=('Times', 20))
    btn_bubble.pack(padx=10,pady=10)
    btn_bubble=Button(new_bubble,text="Bubble Sort vs notation",command=lambda: [popup(new_bubble),plot_bubble_steps_notation()], fg='white', bg='black' , font=('Times', 20))
    btn_bubble.pack(padx=10,pady=10)
    btn_bubble= Button (new_bubble, text="Back",command=lambda:[back(new_bubble)], fg='white', bg='black', padx='100',pady='10' , font=('Times', 20))
    btn_bubble.pack(padx=10,pady=10)
def open_selection():
    root.withdraw()
    new_selection=Toplevel()
    new_selection.title('Selection Sort')
    new_selection.geometry("1200x800")
    new_selection.configure(background='#BC8F8F')
    new_selection.iconbitmap('algorithms ico.ico')
    h_label1 =Label(new_selection,text="Welcome to Selection Sort page!!" , font=('Arial Black', 20), bg='#BC8F8F',padx='100',pady='10',fg='white')
    h_label1.pack()
    h_label2 =Label(new_selection,text="Selection Sort brief" , font=('Arial Black', 20) , bg='#BC8F8F', fg='black',padx='100',pady='10')
    h_label2.pack()
    h_label3=Label (new_selection, text=" Definition: as you set the first element as minimum, then it compares the first and second elements.  ", bg='#BC8F8F' ,font=('Arial Black', 16),padx='100',pady='10' )
    h_label3.pack()
    h_label4=Label (new_selection,text=" Assign the second element to the position of minimum if it is smaller than the first until all become sorted.",bg='#BC8F8F' ,font=('Arial Black', 16),padx='100',pady='10')
    h_label4.pack()
    h_label5=Label(new_selection, text=" Time Complexity: O(n^2)" , bg='#BC8F8F',font=('Arial Black', 16),padx='100',pady='10' )
    h_label5.pack()
    img_selection=ImageTk.PhotoImage(Image.open("selection_img1.jpeg"))
    panel_selection=Label(new_selection,image=img_selection)
    panel_selection.photo=img_selection
    panel_selection.pack()
    btn_selection= Button (new_selection, text="selection Sort Steps Graph",command=lambda: [popup(new_selection),plot_selection_steps()], fg='white', bg='black', padx='100',pady='10' , font=('Times', 20))
    btn_selection.pack(padx=10,pady=10)
    btn_selection=Button(new_selection,text="Selection Sort vs notation",command=lambda: [popup(new_selection),plot_selection_steps_notation()], fg='white', bg='black' , font=('Times', 20))
    btn_selection.pack(padx=10,pady=10)
    btn_selection= Button (new_selection, text="Back",command=lambda:[back(new_selection)], fg='white', bg='black', padx='100',pady='10' , font=('Times', 20))
    btn_selection.pack(padx=10,pady=10)
def open_compare():
    root.withdraw()
    new=Toplevel()
    new.title('CompareGUI')
    new.iconbitmap('algorithms ico.ico')
    new.geometry("1200x1200")
    new.configure(background='black')
    frame_com=LabelFrame(new)
    frame_com.grid(row=0,column=1)
    frame1_new=LabelFrame(new)
    frame1_new.grid(row=3,column=1)  
    new.resizable(False,False)
    my_label_compare=Label(frame_com,text="Now lets start comparing steps", font=('Arial', 24))
    my_label_compare.pack(padx=10,pady=10)
    label2_compare =Label(frame_com,text="kindly Choose your two algorithm to compare :", fg='red', font=('Times', 20) )
    label2_compare.pack(padx=10,pady=10)
    B1_compare =Button (frame1_new,command=lambda:[popup(new),compare_insertion(B1_compare)],text="Insertion Sort",fg='black',bg='#20B2AA', padx='100',pady='10',font=('Arial Black',9))
    B1_compare.pack(padx=10,pady=10)
    B2_compare =Button(frame1_new,command=lambda:[compare_mergee(B2_compare)],text="Merge Sort",fg='black',bg='#20B2AA',padx='100',pady='10',font=('Arial Black',9))
    B2_compare.pack(padx=10,pady=10)
    B3_compare =Button(frame1_new,command=lambda:[compare_heap(B3_compare)],text="Heap Sort" ,fg='black',bg='#20B2AA',padx='100',pady='10',font=('Arial Black',9))
    B3_compare.pack(padx=10,pady=10)
    B4_compare =Button(frame1_new,command=lambda:[compare_quick(B4_compare)],text="Quick Sort" ,fg='black',bg='#20B2AA',padx='100',pady='10',font=('Arial Black',9))
    B4_compare.pack(padx=10,pady=10)
    B5_compare =Button(frame1_new,command=lambda:[popup(new),compare_radix(B5_compare)],text="Radix Sort",fg='black',bg='#20B2AA',padx='100',pady='10',font=('Arial Black',9))
    B5_compare.pack(padx=10,pady=10)
    B6_compare= Button(frame1_new,command=lambda:[compare_counting(B6_compare)],text="Counting Sort",fg='black',bg='#20B2AA', padx='100',pady='10',font=('Arial Black',9))
    B6_compare.pack(padx=10,pady=10)
    B7_compare =Button(frame1_new,command=lambda:[popup(new),compare_bubble(B7_compare)],text="Bubble Sort",fg='black',bg='#20B2AA',padx='100',pady='10',font=('Arial Black',9))
    B7_compare.pack(padx=10,pady=10)
    B8_compare =Button(frame1_new,command=lambda:[popup(new),compare_selection(B8_compare)],text="Selection Sort",fg='black',bg='#20B2AA',padx='100',pady='10',font=('Arial Black',9))
    B8_compare.pack(padx=10,pady=10)
    B9_compare =Button(frame1_new,command=lambda:[back(new)],text="Back",fg='black',bg='#20B2AA',padx='100',pady='10',font=('Arial Black',9))
    B9_compare.pack(padx=10,pady=10)
    img1_compare=ImageTk.PhotoImage(Image.open("comparison.jpg"))
    panel=Label(new,image=img1_compare)
    panel.photo=img1_compare
    panel.grid(row=3,column=6)
    
    
def back(window):
    window.destroy()
    plt.close()
    root.deiconify()    
    
frame = LabelFrame(root)
frame.grid(row=4, column=2)
frame1 = LabelFrame(root)
frame1.grid(row=5, column=2)
img1=ImageTk.PhotoImage(Image.open("cool algo.jpg"))
label=Label(root,image=img1)
label.grid(row=5,column=6)  
my_label1=Label (frame, text="Welcome to our Algorithms App", font=('Arial', 24)).grid(row=2, column=5)
my_label2=Label (frame,text="Lets have fun & play with soritng Algorithms",font=('Chaucer', 15),fg='red').grid(row=3,column=5)
label2 = Label(frame, text="kindly Choose your sorting algorithm Or you can swipe to compare", fg='#708090', font=('Times', 20)).grid(row=4,column=5)
my_button1 = Button (frame1 , text="Insertion Sort",command=open_insertion, fg='black', bg='#20B2AA', padx='100',pady='10',font=('Arial Black',9)).pack(padx=10,pady=10)
my_button2 = Button(frame1,  text="Merge Sort", command=open_merge,fg='black', bg='#20B2AA',padx='100',pady='10',font=('Arial Black',9)).pack(padx=10,pady=10)
my_button3 = Button(frame1,  text="Heap Sort",command=open_heap,fg='black', bg='#20B2AA',padx='100',pady='10',font=('Arial Black',9)).pack(padx=10,pady=10)
my_button4 = Button(frame1,  text="Quick Sort" ,command=open_quick ,fg='black', bg='#20B2AA',padx='100',pady='10',font=('Arial Black', 9)).pack(padx=10,pady=10)
my_button5 = Button(frame1,  text="Radix Sort ",fg='black',command=open_radix, bg='#20B2AA',padx='100',pady='10',font=('Arial Black', 9)).pack(padx=10,pady=10)
my_button6 = Button (frame1 , text="Counting Sort",command=open_counting, fg='black', bg='#20B2AA', padx='100',pady='10',font=('Arial Black', 9)).pack(padx=10,pady=10)
my_button7 = Button(frame1,  text="Bubble Sort",command=open_bubble,fg='black', bg='#20B2AA',padx='100',pady='10',font=('Arial Black', 9)).pack(padx=10,pady=10)
my_button8 = Button(frame1,  text="Selection Sort",command=open_selection,fg='black', bg='#20B2AA',padx='100',pady='10',font=('Arial Black', 9)).pack(padx=10,pady=10)
my_button9 = Button(frame1,  text="Swipe here to compare Algorithms ", fg='black', bg='#20B2AA',padx='100',pady='10', command=open_compare ,font=('Arial Black', 10)).pack(padx=10,pady=10)
root.mainloop()